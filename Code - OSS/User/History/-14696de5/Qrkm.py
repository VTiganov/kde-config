from PIL import Image # Для загрузки и открытия изображений
import numpy as np


image_path = 'raw.png' # Загрузка изображения  
image = Image.open(image_path) # Pillow открывает картинку
image = image.convert('RGBA')  # В РГБА для более удобной работы с прозрачностью.

image_array = np.array(image) # Переводим картинку в нумпай численный список.
# Более подробно: В результате преобразования получается numpy массив. В моем случае он будет
# Трехмерным. Будет храниться количество пикселей по высоте, ширине и 4 значения для каждого пикселя
# А именно (R, G, B, Alpha), каналы и прозрачность. Все цвета, соответственно, в формате RGBA, 
# Из фоторедактора приходилось доставать цвета фона для точного удаления в формате CMYK, что значит
# Процентное соотношение к 255. Например 55% R значит 255*0.55=140.25, откуда и получал нужные значения цветов пикселей.

# Определяю цвета фона, которые будем убирать. Пришлось взять несколько образцов вокруг каждой кошки, чтобы точно все удалилось (цвета не однородные)
background_colors = [
    np.array([242, 209, 97, 255]), # First cat
    np.array([235, 197, 68, 255]),
    np.array([229, 185, 50, 255]),
    np.array([225, 174, 21, 255]), # Third cat
    np.array([214, 164, 6.9, 255]),
    np.array([216, 160, 36.975, 255]), # Second cat
    np.array([185, 138, 4.08, 255]),
    np.array([169, 124, 0, 255]),
    np.array([214, 113.985, 0, 255]), # Fourth cat
    np.array([199.92, 104.04, 2.04, 255]),
    np.array([183.09, 85.935, 0, 255])
]

tolerance = 16  # Допустимое отклонение по цвету, т.к. он не идеально одинаковый на всем фоне

cat_masks = [  # Дополнительно пришлось создать маску для мордочки каждой кошки, потому что похожие цвета все время пытаюстся удалиться.
    (127,135,373,504),   # Создается по координатам: (x1, y1, x2, y2)
    (111,676,364,864),  # От верхнего левого угла до правого нижнего угла.
    (671,654,874,814),
    (668,150,881,327)
    
]

delete_masks = [
    (496,0,533,1024),  # Рамки никак не хотят удаляться, вручную занес координаты.
    # Переход между желтым и оранжевым фоном по всей высоте картинки. Если поставить большое отклонение - то сотрет половину кошек.    
]

# Для каждого из цветов фона создаем маску.
mask = np.zeros(image_array.shape[:2], dtype=bool) # Создается массив, содержащий только два параметра -
# высоту и ширину (Два первых значния из nupy массива) и изначально заполняется значениями 0 - False, и будет заполняться только булевыми значениями в дальнейшем
# это нужно просто для того, чтобы инициализировать все пиксели изображения и в дальнейшем помечать нужные для включения в маску.

for bg_color in background_colors: # Проходим по всем цветам фона, которые нужно удалить.
    diff = np.abs(image_array - bg_color) # Высчитываем разницу между цветом пикселей изображения и цветом объявленного фона
    # Будем получать что-то вроде: [123,251,18] - [118, 247, 13] = [5, 4, 5]
    mask |= np.all(diff <= tolerance, axis=-1)
    # И далее с помощью объявленного коэффициента толерантности действуем следующим образом:
    # Если разность каждого канала между изображением и нужным цветом фона попадает в ограничение толерантности,
    # то добавляем пиксель в маску. Например, для [12,4,25] = [True, True, False] не добавится, потому что 25 за пределами, а
    # для [5,5,15] = [True, True, True] писксель будет добавлен в маску.
    # С помощю условного оператора "ИЛИ" првоеряем на соответствие толернтности по ВСЕМ каналам хотя бы для одного
    # Искомого цвета фона.
    # axis=-1 означает, что проверка проводится вдоль каждой строки.

for x1, y1, x2, y2 in cat_masks:
    mask[y1:y2, x1:x2] = False # Убираем кошек из маски, их координаты создал выше.

for x1, y1, x2, y2 in delete_masks: # Наоборот, добавляем ненужную рамку для удаления, что создал и описал выше.
    mask[y1:y2, x1:x2] = True

image_array[mask] = [255, 255, 255, 255]  # Сделал фон белым. С помощью маски из всех нулей можно сделать полностью прозрачный.


"""
Почему здесь не обойтись без циклов!

1. Если будет выставлена большая толерантность, (хотя бы на несколько пунктов) то половина котов будет удаляться.
2. Следовательно, нужно было аккуратно подать в программу примерные цвета фона, на которые она должна ориентироваться
и удалять их с совсем небольшим смещением.
3. Даже если не использовать цикл для обработки разных фоновых цветов, а просто создать маски котов для игнорирования
и пройтись с огромной толерантностью каким-то желтым цветом, то все равно получится цикл для применения масок на мордочки
животных, а точность работы будет заметно хуже.
4. С помощью небольшой ручной корректировки удалось аккуратно выделить и удалить фон, считаю, что по техническому заданию 
все сделано неплохо.
5. Для определения конкретных цветов пользовался фоторедактором (На линуксе RawTheraPee), оттуда доставал координаты пикселей,
а из процентного формата цвета CMYK с помощью калькулятора переводил в RGB с помощью (percent / 100 * 255), соответственно,
четвертое значение в RGBA (alpha - transparency) всегда брал за 255 (100% непрозрачно), так как в исходной картинке все явно плотно закрашено.
"""

transparent_image = Image.fromarray(image_array, 'RGBA') # Снова получаем картинку из числового представления изображения.

# Сохранил картинку
output_path = 'enhanced.png' 
transparent_image.save(output_path)